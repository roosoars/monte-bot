#!/usr/bin/env bash
set -euo pipefail

# Configuration values; adjust if you need a different SSID, passphrase, or IP range.
HOTSPOT_SSID="MonteHotspot"
HOTSPOT_PASSWORD="Rod2804@"
HOTSPOT_CHANNEL="6"
HOTSPOT_COUNTRY="BR"
HOTSPOT_IP="192.168.50.1"
HOTSPOT_NET="192.168.50.0"
HOTSPOT_RANGE_START="192.168.50.10"
HOTSPOT_RANGE_END="192.168.50.100"
HOTSPOT_ROUTER="192.168.50.1"
HOTSPOT_LEASE="24h"
WLAN_IFACE="wlan0"

require_root() {
  if [[ $(id -u) -ne 0 ]]; then
    echo "[ERROR] Run this script as root (sudo)." >&2
    exit 1
  fi
}

check_operating_system() {
  local os_id
  os_id=$(awk -F= '/^ID=/{gsub(/"/, ""); print $2}' /etc/os-release)
  local version
  version=$(awk -F= '/^VERSION_ID=/{gsub(/"/, ""); print $2}' /etc/os-release)
  if [[ ${os_id} != "raspbian" && ${os_id} != "debian" ]]; then
    echo "[WARNING] This script was written for Raspberry Pi OS (Bookworm). Proceed with caution." >&2
  fi
  if [[ ${version} != "12" ]]; then
    echo "[WARNING] Detected VERSION_ID=${version}. Expected 12 (Bookworm)." >&2
  fi
}

disable_rfkill_stack() {
  systemctl stop rfkill.service rfkill-block@${WLAN_IFACE}.service >/dev/null 2>&1 || true
  systemctl stop rfkill-block@.service systemd-rfkill.service systemd-rfkill.socket >/dev/null 2>&1 || true
  systemctl disable rfkill.service rfkill-block@${WLAN_IFACE}.service >/dev/null 2>&1 || true
  systemctl disable rfkill-block@.service systemd-rfkill.service systemd-rfkill.socket >/dev/null 2>&1 || true
  systemctl mask rfkill.service rfkill-block@${WLAN_IFACE}.service >/dev/null 2>&1 || true
  systemctl mask rfkill-block@.service systemd-rfkill.service systemd-rfkill.socket >/dev/null 2>&1 || true
  ln -sf /dev/null /etc/systemd/system/systemd-rfkill.service
  ln -sf /dev/null /etc/systemd/system/systemd-rfkill.socket
  ln -sf /dev/null /etc/systemd/system/rfkill.service
  ln -sf /dev/null /etc/systemd/system/rfkill-block@.service
  rm -rf /var/lib/systemd/rfkill
}

disable_wpa_supplicant() {
  systemctl disable --now wpa_supplicant.service wpa_supplicant@${WLAN_IFACE}.service >/dev/null 2>&1 || true
  pkill -f wpa_supplicant || true
}

install_packages() {
  export DEBIAN_FRONTEND=noninteractive
  apt-get update
  apt-get install -y --no-install-recommends hostapd dnsmasq nginx dhcpcd5
  systemctl stop hostapd || true
  systemctl stop dnsmasq || true
  systemctl stop nginx || true
  apt-get purge -y rfkill >/dev/null 2>&1 || true
  apt-get autoremove -y >/dev/null 2>&1 || true
}

ensure_dhcpcd() {
  local dhcpcd_conf="/etc/dhcpcd.conf"
  if [[ ! -f ${dhcpcd_conf} ]]; then
    cat <<'EOF' >"${dhcpcd_conf}"
# Minimal dhcpcd configuration generated by setup_hotspot.sh
hostname
clientid
persistent
option rapid_commit
option domain_name_servers, domain_name, domain_search
option classless_static_routes
option interface_mtu
require dhcp_server_identifier
slaac private
EOF
  fi
  systemctl enable dhcpcd >/dev/null 2>&1 || true
  systemctl start dhcpcd || true
}

configure_rfkill_unit() {
  local script_path="/usr/local/sbin/hotspot-unblock-rfkill.sh"
  local unit_path="/etc/systemd/system/hotspot-rfkill-unblock.service"

  cat <<'EOF' >"${script_path}"
#!/usr/bin/env bash
set -euo pipefail

# Remove any persisted rfkill blocks so Wi-Fi starts unblocked.
if [[ -d /var/lib/systemd/rfkill ]]; then
  find /var/lib/systemd/rfkill -type f -delete || true
else
  mkdir -p /var/lib/systemd/rfkill
fi

for rf_path in /sys/class/rfkill/rfkill*; do
  [[ -d ${rf_path} ]] || continue
  echo 0 >"${rf_path}/soft" 2>/dev/null || true
  echo 0 >"${rf_path}/hard" 2>/dev/null || true
done
exit 0
EOF
  chmod 755 "${script_path}"

  cat <<'EOF' >"${unit_path}"
[Unit]
Description=Ensure wlan rfkill stays unblocked
DefaultDependencies=no
After=local-fs.target
Before=network-pre.target hostapd.service
Wants=network-pre.target

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/hotspot-unblock-rfkill.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable hotspot-rfkill-unblock.service
  systemctl start hotspot-rfkill-unblock.service
}

configure_hotspot_startup() {
  local startup_script="/usr/local/sbin/hotspot-startup.sh"
  local startup_unit="/etc/systemd/system/hotspot-startup.service"

  cat <<'EOF' >"${startup_script}"
#!/usr/bin/env bash
set -euo pipefail

WLAN_IFACE="${WLAN_IFACE:-wlan0}"
MAX_WAIT=60
LOG_TAG="hotspot-startup"

log_info() {
  echo "[INFO] $1"
  logger -t "${LOG_TAG}" "[INFO] $1"
}

log_error() {
  echo "[ERROR] $1" >&2
  logger -t "${LOG_TAG}" "[ERROR] $1"
}

# Wait for wireless interface to be available
wait_for_interface() {
  log_info "Waiting for interface ${WLAN_IFACE} to be available..."
  local count=0
  while [[ ! -d "/sys/class/net/${WLAN_IFACE}" ]]; do
    if [[ ${count} -ge ${MAX_WAIT} ]]; then
      log_error "Interface ${WLAN_IFACE} not found after ${MAX_WAIT} seconds"
      return 1
    fi
    sleep 1
    count=$((count + 1))
  done
  log_info "Interface ${WLAN_IFACE} found after ${count} seconds"
  return 0
}

# Ensure rfkill is unblocked
unblock_rfkill() {
  log_info "Unblocking rfkill for wireless devices..."
  for rf_path in /sys/class/rfkill/rfkill*; do
    [[ -d ${rf_path} ]] || continue
    # Only unblock soft blocks (hardware blocks cannot be controlled by software)
    if [[ -w "${rf_path}/soft" ]]; then
      echo 0 >"${rf_path}/soft" 2>/dev/null || true
    fi
  done
  # Also use rfkill command if available
  command -v rfkill >/dev/null 2>&1 && rfkill unblock all || true
  log_info "rfkill unblock completed"
}

# Wait for interface to be ready for configuration
wait_for_interface_ready() {
  log_info "Waiting for interface ${WLAN_IFACE} to be ready..."
  local count=0
  while ! ip link show "${WLAN_IFACE}" >/dev/null 2>&1; do
    if [[ ${count} -ge ${MAX_WAIT} ]]; then
      log_error "Interface ${WLAN_IFACE} not ready after ${MAX_WAIT} seconds"
      return 1
    fi
    sleep 1
    count=$((count + 1))
  done
  log_info "Interface ${WLAN_IFACE} ready after ${count} seconds"
  return 0
}

# Bring interface up
bring_interface_up() {
  log_info "Bringing interface ${WLAN_IFACE} up..."
  ip link set "${WLAN_IFACE}" up 2>/dev/null || true
  sleep 2
}

# Start service with retry logic
start_service_with_retry() {
  local service=$1
  local max_retries=3
  local retry=0

  while [[ ${retry} -lt ${max_retries} ]]; do
    log_info "Starting ${service} (attempt $((retry + 1))/${max_retries})..."
    if systemctl start "${service}"; then
      log_info "${service} started successfully"
      return 0
    fi
    retry=$((retry + 1))
    sleep 2
  done

  log_error "Failed to start ${service} after ${max_retries} attempts"
  return 1
}

# Main startup sequence
main() {
  log_info "Starting hotspot startup sequence..."

  # Wait for wireless interface
  if ! wait_for_interface; then
    log_error "Failed waiting for wireless interface"
    exit 1
  fi

  # Unblock rfkill
  unblock_rfkill

  # Wait for interface to be ready
  if ! wait_for_interface_ready; then
    log_error "Failed waiting for interface to be ready"
    exit 1
  fi

  # Bring interface up
  bring_interface_up

  # Stop services if they are running (to ensure clean start)
  log_info "Stopping services for clean start..."
  systemctl stop hostapd 2>/dev/null || true
  systemctl stop dnsmasq 2>/dev/null || true
  sleep 1

  # Start dhcpcd to configure the static IP
  log_info "Ensuring dhcpcd is running..."
  systemctl start dhcpcd || true
  sleep 3

  # Wait for IPv4 address to be configured
  log_info "Waiting for IP configuration on ${WLAN_IFACE}..."
  local ip_wait=0
  while ! ip addr show "${WLAN_IFACE}" 2>/dev/null | grep -q 'inet [0-9]'; do
    if [[ ${ip_wait} -ge 30 ]]; then
      log_error "IP not configured on ${WLAN_IFACE} after 30 seconds"
      break
    fi
    sleep 1
    ip_wait=$((ip_wait + 1))
  done

  # Start dnsmasq
  start_service_with_retry dnsmasq || true
  sleep 2

  # Start hostapd
  start_service_with_retry hostapd || true
  sleep 2

  # Start nginx
  start_service_with_retry nginx || true

  log_info "Hotspot startup sequence completed"
  
  # Log final status
  log_info "Service status:"
  log_info "  dhcpcd: $(systemctl is-active dhcpcd)"
  log_info "  dnsmasq: $(systemctl is-active dnsmasq)"
  log_info "  hostapd: $(systemctl is-active hostapd)"
  log_info "  nginx: $(systemctl is-active nginx)"

  exit 0
}

main "$@"
EOF
  chmod 755 "${startup_script}"

  cat <<'EOF' >"${startup_unit}"
[Unit]
Description=Hotspot Startup Sequencer
After=local-fs.target sysinit.target hotspot-rfkill-unblock.service
Wants=hotspot-rfkill-unblock.service
Before=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/hotspot-startup.sh
RemainAfterExit=yes
TimeoutStartSec=120

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable hotspot-startup.service
}

configure_dhcpcd() {
  local marker_begin="# hotspot-setup begin"
  local marker_end="# hotspot-setup end"
  local dhcpcd_conf="/etc/dhcpcd.conf"

  sed -i "/${marker_begin}/,/${marker_end}/d" "${dhcpcd_conf}"
  cat <<EOF >>"${dhcpcd_conf}"
${marker_begin}
interface ${WLAN_IFACE}
static ip_address=${HOTSPOT_IP}/24
nohook wpa_supplicant
${marker_end}
EOF
}

configure_sysctl() {
  local sysctl_conf="/etc/sysctl.d/99-hotspot.conf"
  cat <<EOF >"${sysctl_conf}"
net.ipv4.ip_forward=0
EOF
  sysctl -w net.ipv4.ip_forward=0 >/dev/null
}

configure_dnsmasq() {
  local dnsmasq_conf="/etc/dnsmasq.d/hotspot.conf"
  mkdir -p /etc/dnsmasq.d
  cat <<EOF >"${dnsmasq_conf}"
interface=${WLAN_IFACE}
dhcp-range=${HOTSPOT_RANGE_START},${HOTSPOT_RANGE_END},255.255.255.0,${HOTSPOT_LEASE}
dhcp-option=option:router,${HOTSPOT_ROUTER}
dhcp-option=option:dns-server,${HOTSPOT_ROUTER}
address=/gw/${HOTSPOT_IP}
log-queries
log-dhcp
EOF
  sed -i 's/^conf-dir=/#&/' /etc/dnsmasq.conf
  if ! grep -q '^conf-dir=/etc/dnsmasq.d' /etc/dnsmasq.conf; then
    echo 'conf-dir=/etc/dnsmasq.d' >>/etc/dnsmasq.conf
  fi
}

configure_hostapd() {
  local hostapd_conf="/etc/hostapd/hostapd.conf"
  cat <<EOF >"${hostapd_conf}"
country_code=${HOTSPOT_COUNTRY}
interface=${WLAN_IFACE}
ssid=${HOTSPOT_SSID}
hw_mode=g
channel=${HOTSPOT_CHANNEL}
wmm_enabled=0
ieee80211n=1
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=${HOTSPOT_PASSWORD}
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
EOF
  sed -i 's|^#*\s*DAEMON_CONF=.*|DAEMON_CONF="/etc/hostapd/hostapd.conf"|' /etc/default/hostapd
}

configure_nginx() {
  local doc_root="/var/www/html"
  mkdir -p "${doc_root}"
  cat <<'EOF' >"${doc_root}/index.html"
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hello</title>
  <style>
    body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #111; color: #0f0; }
    h1 { font-size: 4rem; letter-spacing: 0.2rem; }
  </style>
</head>
<body>
  <h1>HELLO</h1>
</body>
</html>
EOF
  chown -R www-data:www-data "${doc_root}"
  chmod -R 755 "${doc_root}"
  systemctl enable nginx
  systemctl restart nginx
}

restore_services() {
  systemctl unmask hostapd || true
  systemctl enable dhcpcd
  systemctl enable hostapd
  systemctl enable dnsmasq
  systemctl enable nginx
  systemctl restart dhcpcd
  sleep 2
  systemctl restart dnsmasq
  sleep 1
  systemctl restart hostapd
  sleep 1
  systemctl restart nginx
}

main() {
  require_root
  check_operating_system
  disable_rfkill_stack
  disable_wpa_supplicant
  install_packages
  ensure_dhcpcd
  configure_rfkill_unit
  configure_hotspot_startup
  configure_dhcpcd
  configure_sysctl
  configure_dnsmasq
  configure_hostapd
  configure_nginx
  restore_services
  echo "[INFO] Hotspot setup complete. Reboot to ensure all settings persist." >&2
}

main "$@"